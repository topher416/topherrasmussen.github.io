<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radiohead Ensemble - December 14, 2025</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }

        #board {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        .scan-line {
            position: fixed;
            width: 100%;
            height: 3px;
            background: linear-gradient(transparent, rgba(139, 0, 139, 0.5), transparent);
            animation: scan 4s linear infinite;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes scan {
            0% { top: 0%; }
            100% { top: 100%; }
        }

        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            opacity: 0.05;
            z-index: 5;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.2' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            animation: noise-shift 0.5s infinite;
        }

        @keyframes noise-shift {
            0%, 100% { opacity: 0.05; }
            50% { opacity: 0.08; }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
</head>
<body>
    <canvas id="board"></canvas>
    <div class="scan-line"></div>
    <div class="noise-overlay"></div>
    
    <div class="sr-only">
        RADIOHEAD ENSEMBLE
        December 14, 2025 at 4:00 PM
        Old Town School of Folk Music
        909 West Armitage, Lincoln Park, Chicago, Illinois
        A Live Performance
    </div>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        
        const CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/~`█▓▒░';
        const MESSAGE_LINES = [
            'RADIOHEAD',
            'ENSEMBLE',
            '',
            'DECEMBER 14 2025',
            '4:00 PM',
            '',
            'OLD TOWN SCHOOL',
            'OF FOLK MUSIC',
            '909 W ARMITAGE',
            'LINCOLN PARK',
            'CHICAGO IL'
        ];

        const GOTH_COLORS = [
            '#8B008B', '#4B0082', '#800080', '#9400D3', '#6A0DAD', '#663399',
            '#8A2BE2', '#9932CC', '#BA55D3', '#FF00FF', '#DA70D6', '#EE82EE'
        ];

        let cols, rows, cellWidth, cellHeight, dpr;
        let cells = [];
        let messageMap = [];
        let time = 0;
        let phase = 'REVEAL_WATERFALL';
        let phaseStartTime = 0;
        let revealEndAt = 0;
        let holdEndAt = 0;
        let scanPos = 0;
        let scanSpeed = 220;
        let bandThickness = 3;

        class Cell {
            constructor(x, y, col, row) {
                this.x = x;
                this.y = y;
                this.col = col;
                this.row = row;
                this.currentChar = this.randomChar();
                this.targetChar = null;
                this.isMessage = false;
                this.corruption = 1.0;
                this.corruptionTarget = 1.0;
                this.flipRate = 40 + Math.random() * 80;
                this.nextFlipAt = 0;
                this.revealAt = Infinity;
                this.lastRevealedAt = 0;
                this.hue = Math.random() * 360;
                this.glitchOffset = { x: 0, y: 0 };
            }

            randomChar() {
                return CHARSET[Math.floor(Math.random() * CHARSET.length)];
            }

            update(now, dt) {
                if (phase === 'REVEAL_WATERFALL') {
                    if (now >= this.revealAt && this.corruption > 0) {
                        this.corruption = Math.max(0, this.corruption - dt * 0.004);
                        if (this.corruption <= 0 && this.isMessage && this.targetChar) {
                            this.currentChar = this.targetChar;
                        }
                    }
                }

                if (this.corruption > 0.1) {
                    if (now >= this.nextFlipAt) {
                        this.currentChar = this.randomChar();
                        this.nextFlipAt = now + this.flipRate;
                    }
                }

                if (this.corruptionTarget !== this.corruption) {
                    const diff = this.corruptionTarget - this.corruption;
                    this.corruption += diff * dt * 0.006;
                    if (Math.abs(diff) < 0.01) {
                        this.corruption = this.corruptionTarget;
                    }
                }

                if (this.corruption < 0.1 && this.isMessage && this.targetChar) {
                    this.currentChar = this.targetChar;
                }
            }

            applyCorruption(amount) {
                if (this.isMessage && this.corruption < 0.8) {
                    this.corruptionTarget = Math.min(1.0, this.corruption + amount);
                }
            }

            draw(now) {
                const colorIndex = Math.floor((this.hue / 360) * GOTH_COLORS.length);
                const color = GOTH_COLORS[colorIndex % GOTH_COLORS.length];
                
                let brightness;
                if (this.isMessage) {
                    brightness = 1.0 - (this.corruption * 0.65);
                } else {
                    brightness = 0.15 + (this.corruption * 0.15);
                }
                
                const drawX = this.x + this.glitchOffset.x;
                const drawY = this.y + this.glitchOffset.y;
                
                const isRecentlyRevealed = (now - this.lastRevealedAt) < 400;
                const showOutline = (phase === 'HOLD_CRISP' || isRecentlyRevealed) && 
                                   this.isMessage && this.corruption < 0.2;
                
                if (showOutline) {
                    ctx.lineWidth = dpr * 0.8;
                    ctx.strokeStyle = '#fff';
                    ctx.globalAlpha = brightness;
                    ctx.strokeText(this.currentChar, drawX, drawY);
                }
                
                ctx.globalAlpha = brightness;
                ctx.fillStyle = color;
                
                if (this.isMessage && this.corruption < 0.3) {
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 8 * dpr;
                    ctx.fillText(this.currentChar, drawX, drawY);
                    ctx.shadowBlur = 0;
                } else {
                    ctx.fillText(this.currentChar, drawX, drawY);
                }
                
                ctx.globalAlpha = 1;
            }
        }

        function initCanvas() {
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            
            const isMobile = window.innerWidth < 768;
            const fontSize = isMobile ? 18 : 20;
            ctx.font = `${fontSize * dpr}px "Courier New", monospace`;
            ctx.textBaseline = 'top';
            
            const metrics = ctx.measureText('M');
            cellWidth = metrics.width;
            cellHeight = fontSize * dpr * 1.2;
            
            cols = Math.floor(canvas.width / cellWidth);
            rows = Math.floor(canvas.height / cellHeight);
            
            cells = [];
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * cellWidth;
                    const y = row * cellHeight;
                    cells.push(new Cell(x, y, col, row));
                }
            }
            
            createMessageMap();
            startWaterfallReveal();
        }

        function createMessageMap() {
            const offscreen = document.createElement('canvas');
            offscreen.width = canvas.width;
            offscreen.height = canvas.height;
            const octx = offscreen.getContext('2d');
            octx.font = ctx.font;
            octx.textBaseline = 'top';
            octx.fillStyle = 'white';
            
            const startY = (canvas.height - MESSAGE_LINES.length * cellHeight) / 2;
            
            MESSAGE_LINES.forEach((line, lineIdx) => {
                const lineWidth = octx.measureText(line).width;
                const startX = (canvas.width - lineWidth) / 2;
                octx.fillText(line, startX, startY + lineIdx * cellHeight);
            });
            
            const imageData = octx.getImageData(0, 0, canvas.width, canvas.height);
            messageMap = [];
            
            cells.forEach(cell => {
                const px = Math.floor(cell.x);
                const py = Math.floor(cell.y);
                const idx = (py * canvas.width + px) * 4;
                const alpha = imageData.data[idx + 3];
                
                if (alpha > 128) {
                    cell.isMessage = true;
                    const charX = Math.floor((px - (canvas.width - octx.measureText(MESSAGE_LINES[0]).width) / 2) / cellWidth);
                    const lineIdx = Math.floor((py - startY) / cellHeight);
                    if (lineIdx >= 0 && lineIdx < MESSAGE_LINES.length) {
                        const line = MESSAGE_LINES[lineIdx];
                        const charIdx = Math.floor((px - (canvas.width - octx.measureText(line).width) / 2) / cellWidth);
                        if (charIdx >= 0 && charIdx < line.length) {
                            cell.targetChar = line[charIdx];
                        }
                    }
                    messageMap.push(cell);
                }
            });
        }

        function startWaterfallReveal() {
            phase = 'REVEAL_WATERFALL';
            phaseStartTime = Date.now();
            const rowDelay = 20;
            
            cells.forEach(cell => {
                cell.corruption = 1.0;
                cell.corruptionTarget = 1.0;
                cell.revealAt = phaseStartTime + cell.row * rowDelay + Math.random() * 12;
            });
            
            const lastRow = Math.max(...cells.map(c => c.row));
            revealEndAt = phaseStartTime + lastRow * rowDelay + 500;
            holdEndAt = revealEndAt + 2500;
        }

        function triggerRippleReveal(x, y) {
            const radius = window.innerWidth < 768 ? 160 : 200;
            
            cells.forEach(cell => {
                const dx = cell.x - x;
                const dy = cell.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < radius && cell.isMessage) {
                    cell.corruptionTarget = 0;
                    cell.lastRevealedAt = Date.now();
                }
            });
        }

        function updateCRTScan(dt) {
            if (phase !== 'DEGRADE_CRT') return;
            
            scanPos += scanSpeed * dt / 1000;
            if (scanPos > canvas.height) {
                scanPos = 0;
            }
            
            const scanRow = Math.floor(scanPos / cellHeight);
            
            cells.forEach(cell => {
                if (Math.abs(cell.row - scanRow) < bandThickness) {
                    cell.applyCorruption(0.18);
                }
            });
        }

        let lastTime = Date.now();
        function animate() {
            const now = Date.now();
            const dt = now - lastTime;
            lastTime = now;
            time = now;
            
            if (phase === 'REVEAL_WATERFALL' && now >= revealEndAt) {
                phase = 'HOLD_CRISP';
            }
            
            if (phase === 'HOLD_CRISP' && now >= holdEndAt) {
                phase = 'DEGRADE_CRT';
                scanPos = 0;
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            updateCRTScan(dt);
            
            cells.forEach(cell => {
                cell.update(now, dt);
                cell.draw(now);
            });
            
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;
            triggerRippleReveal(x, y);
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = (touch.clientX - rect.left) * dpr;
            const y = (touch.clientY - rect.top) * dpr;
            triggerRippleReveal(x, y);
        });

        window.addEventListener('resize', () => {
            initCanvas();
        });

        initCanvas();
        animate();
    </script>
</body>
</html>
