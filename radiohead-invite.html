<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radiohead Ensemble - December 14, 2025</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }

        #board {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        .scan-line {
            position: fixed;
            width: 100%;
            height: 3px;
            background: linear-gradient(transparent, rgba(139, 0, 139, 0.5), transparent);
            animation: scan 4s linear infinite;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes scan {
            0% { top: 0%; }
            100% { top: 100%; }
        }

        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            opacity: 0.02;
            z-index: 5;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.2' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            animation: noise-shift 0.5s infinite;
        }

        @keyframes noise-shift {
            0%, 100% { opacity: 0.02; }
            50% { opacity: 0.04; }
        }
        
        @media (max-width: 767px) {
            .noise-overlay {
                opacity: 0.01;
            }
            
            @keyframes noise-shift {
                0%, 100% { opacity: 0.01; }
                50% { opacity: 0.02; }
            }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
</head>
<body>
    <canvas id="board"></canvas>
    <div class="scan-line"></div>
    <div class="noise-overlay"></div>
    
    <div class="sr-only">
        RADIOHEAD ENSEMBLE
        December 14, 2025 at 4:00 PM
        Old Town School of Folk Music
        909 West Armitage, Lincoln Park, Chicago, Illinois
        A Live Performance
    </div>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        
        const CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/~`█▓▒░';
        const MESSAGE_LINES = [
            'RADIOHEAD',
            'ENSEMBLE',
            '',
            'DECEMBER 14 2025',
            '4:00 PM',
            '',
            'OLD TOWN SCHOOL',
            'OF FOLK MUSIC',
            '909 W ARMITAGE',
            'LINCOLN PARK',
            'CHICAGO IL'
        ];

        const GOTH_COLORS = [
            '#8B008B', // dark magenta
            '#4B0082', // indigo
            '#800080', // purple
            '#9400D3', // dark violet
            '#6A0DAD', // purple
            '#663399', // rebecca purple
            '#8A2BE2', // blue violet
            '#9932CC', // dark orchid
            '#BA55D3', // medium orchid
            '#FF00FF', // magenta
            '#DA70D6', // orchid
            '#EE82EE', // violet
        ];

        let cols, rows, cellWidth, cellHeight;
        let cells = [];
        let messageMap = [];
        let ripples = [];
        let time = 0;
        let glitchBands = [];
        let autoRippleInterval = null;
        let messageSettled = false;
        let trailEffects = [];
        let isDrawing = false;
        let lastTrailPoint = null;

        class TrailEffect {
            constructor(x, y, startTime) {
                this.x = x;
                this.y = y;
                this.startTime = startTime;
                this.duration = 6000; // 6 seconds
                this.affectedCells = [];
                this.originalStates = new Map();
                
                // Find cells within radius and store their original states
                const radius = 100 + Math.random() * 100;
                cells.forEach(cell => {
                    const dx = cell.x - x;
                    const dy = cell.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius) {
                        this.affectedCells.push({
                            cell: cell,
                            distance: dist,
                            angle: Math.atan2(dy, dx)
                        });
                        
                        // Store original state
                        this.originalStates.set(cell, {
                            char: cell.currentChar,
                            isMessage: cell.isMessage,
                            targetChar: cell.targetChar,
                            settled: cell.settled,
                            brightness: cell.brightness,
                            hue: cell.hue
                        });
                    }
                });
            }
            
            update(currentTime) {
                const elapsed = currentTime - this.startTime;
                const progress = Math.min(elapsed / this.duration, 1);
                
                if (progress < 0.5) {
                    // First 3 seconds: ripple out effect
                    const rippleProgress = progress * 2;
                    this.affectedCells.forEach(({ cell, distance, angle }) => {
                        const ripplePhase = (distance / 200) - rippleProgress * 2;
                        
                        if (Math.abs(ripplePhase) < 0.3) {
                            // Transform character
                            cell.currentChar = CHARSET[Math.floor(Math.random() * CHARSET.length)];
                            cell.brightness = 0.8 + Math.random() * 0.2;
                            cell.hue = (cell.hue + 120) % 360;
                            
                            // Add ripple displacement
                            const intensity = 1 - Math.abs(ripplePhase) / 0.3;
                            cell.glitchOffset = {
                                x: Math.cos(angle) * intensity * 8,
                                y: Math.sin(angle) * intensity * 8
                            };
                        }
                    });
                } else {
                    // Last 3 seconds: return to original state
                    const returnProgress = (progress - 0.5) * 2;
                    this.affectedCells.forEach(({ cell }) => {
                        const original = this.originalStates.get(cell);
                        if (returnProgress > 0.8) {
                            if (cell.isMessage) {
                                // Message cells always snap back to their canonical state
                                cell.currentChar = cell.targetChar;
                                cell.settled = true;
                                cell.flipRate = Infinity;
                                cell.brightness = 1;
                                cell.glitchOffset = { x: 0, y: 0 };
                            } else if (original) {
                                // Non-message cells return to their snapshot state
                                cell.currentChar = original.char;
                                cell.brightness = original.brightness;
                                cell.hue = original.hue;
                                cell.glitchOffset = { x: 0, y: 0 };
                                cell.settled = original.settled;
                            }
                        }
                    });
                }
                
                return progress >= 1;
            }
        }

        class Cell {
            constructor(x, y, col, row) {
                this.x = x;
                this.y = y;
                this.col = col;
                this.row = row;
                this.currentChar = this.randomChar();
                this.targetChar = null;
                this.isMessage = false;
                this.flipRate = 30 + Math.random() * 90;
                this.nextFlipAt = time + Math.random() * 100;
                this.settleAt = Infinity;
                this.settled = false;
                this.hue = Math.random() * 360;
                this.brightness = 0.3 + Math.random() * 0.7;
                this.glitchOffset = { x: 0, y: 0 };
            }

            randomChar() {
                return CHARSET[Math.floor(Math.random() * CHARSET.length)];
            }

            update(now) {
                if (now >= this.nextFlipAt && !this.settled) {
                    this.currentChar = this.randomChar();
                    this.nextFlipAt = now + this.flipRate;
                }

                if (now >= this.settleAt && !this.settled) {
                    if (this.isMessage && this.targetChar) {
                        this.currentChar = this.targetChar;
                        this.settled = true;
                        this.flipRate = Infinity;
                        this.brightness = 1;
                    } else {
                        this.flipRate = 200 + Math.random() * 300;
                        this.brightness *= 0.15;
                    }
                }

                if (this.settled && !this.isMessage && Math.random() < 0.001) {
                    this.currentChar = this.randomChar();
                    setTimeout(() => {
                        this.currentChar = this.targetChar;
                    }, 50);
                }
            }

            draw() {
                const drawX = this.x + this.glitchOffset.x;
                const drawY = this.y + this.glitchOffset.y;
                
                if (this.isMessage && this.settled) {
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#fff';
                    ctx.shadowColor = '#FF00FF';
                    ctx.shadowBlur = 12;
                    ctx.fillText(this.currentChar, drawX, drawY);
                    ctx.shadowBlur = 0;
                } else {
                    const colorIndex = Math.floor((this.hue / 360) * GOTH_COLORS.length);
                    const color = GOTH_COLORS[colorIndex % GOTH_COLORS.length];
                    ctx.globalAlpha = this.brightness;
                    ctx.fillStyle = color;
                    ctx.fillText(this.currentChar, drawX, drawY);
                }
                
                ctx.globalAlpha = 1;
            }
        }

        function initCanvas() {
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            
            const isMobile = window.innerWidth < 768;
            const fontSize = isMobile ? 18 : 22;
            ctx.font = `${fontSize * dpr}px "Courier New", monospace`;
            ctx.textBaseline = 'top';
            
            const metrics = ctx.measureText('M');
            cellWidth = metrics.width;
            cellHeight = fontSize * dpr * 1.2;
            
            cols = Math.floor(canvas.width / cellWidth);
            rows = Math.floor(canvas.height / cellHeight);
            
            cells = [];
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * cellWidth;
                    const y = row * cellHeight;
                    cells.push(new Cell(x, y, col, row));
                }
            }
            
            createMessageMap();
            triggerRipple(canvas.width / 2, canvas.height / 2);
        }

        function createMessageMap() {
            messageMap = [];
            
            // Calculate starting row for centered message
            const startRow = Math.floor((rows - MESSAGE_LINES.length) / 2);
            
            MESSAGE_LINES.forEach((line, lineIdx) => {
                if (line.length === 0) return; // Skip empty lines
                
                const row = startRow + lineIdx;
                if (row < 0 || row >= rows) return;
                
                // Calculate starting column for centered line
                const startCol = Math.floor((cols - line.length) / 2);
                
                // Assign each character to a specific grid cell
                for (let charIdx = 0; charIdx < line.length; charIdx++) {
                    const col = startCol + charIdx;
                    if (col < 0 || col >= cols) continue;
                    
                    // Find the cell at this row/col
                    const cellIndex = row * cols + col;
                    if (cellIndex >= 0 && cellIndex < cells.length) {
                        const cell = cells[cellIndex];
                        cell.isMessage = true;
                        cell.targetChar = line[charIdx];
                        messageMap.push(cell);
                    }
                }
            });
        }

        function triggerRipple(x, y) {
            const speed = 0.3;
            const jitter = 50;
            
            cells.forEach(cell => {
                const dx = cell.x - x;
                const dy = cell.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                cell.settleAt = time + dist * speed + Math.random() * jitter;
                cell.settled = false;
            });
        }

        function resetMessageNow() {
            if (!messageMap || messageMap.length === 0) return;
            messageMap.forEach(cell => {
                if (!cell) return;
                cell.currentChar = cell.targetChar;
                cell.settled = true;
                cell.flipRate = Infinity;
                cell.brightness = 1;
                cell.glitchOffset = { x: 0, y: 0 };
            });
        }

        function triggerGlitchBand() {
            const isHorizontal = Math.random() > 0.5;
            const position = Math.random();
            const thickness = 3 + Math.floor(Math.random() * 8);
            const duration = 100 + Math.random() * 150;
            const endTime = time + duration;
            
            glitchBands.push({
                isHorizontal,
                position,
                thickness,
                endTime,
                offset: { x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4 }
            });
        }

        function updateGlitchBands() {
            glitchBands = glitchBands.filter(band => time < band.endTime);
            
            cells.forEach(cell => {
                cell.glitchOffset = { x: 0, y: 0 };
            });
            
            glitchBands.forEach(band => {
                cells.forEach(cell => {
                    const pos = band.isHorizontal ? cell.row : cell.col;
                    const max = band.isHorizontal ? rows : cols;
                    const bandPos = band.position * max;
                    
                    if (Math.abs(pos - bandPos) < band.thickness && !(cell.isMessage && cell.settled)) {
                        cell.glitchOffset = band.offset;
                        cell.hue = (cell.hue + 180) % 360;
                    }
                });
            });
        }

        function animate() {
            time = Date.now();
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            updateGlitchBands();
            
            // Update trail effects
            trailEffects = trailEffects.filter(effect => !effect.update(time));
            
            cells.forEach(cell => {
                cell.update(time);
                cell.draw();
            });
            
            // Check if message has settled
            if (!messageSettled && messageMap.length > 0) {
                const allSettled = messageMap.every(cell => cell.settled);
                if (allSettled) {
                    messageSettled = true;
                    if (autoRippleInterval) {
                        clearInterval(autoRippleInterval);
                        autoRippleInterval = null;
                    }
                }
            }
            
            if (Math.random() < 0.02) {
                triggerGlitchBand();
            }
            
            requestAnimationFrame(animate);
        }

        function createTrailEffect(x, y) {
            // Only create trail if enough distance from last point
            if (lastTrailPoint) {
                const dx = x - lastTrailPoint.x;
                const dy = y - lastTrailPoint.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minStep = window.innerWidth < 768 ? 15 : 30;
                if (dist < minStep) return; // Minimum distance between trail points
            }
            
            trailEffects.push(new TrailEffect(x, y, time));
            lastTrailPoint = { x, y };
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;
            createTrailEffect(x, y);
        });

        // Mouse drag events
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;
            createTrailEffect(x, y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;
            createTrailEffect(x, y);
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            lastTrailPoint = null;
            setTimeout(resetMessageNow, 1200);
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            lastTrailPoint = null;
        });

        // Touch events for mobile
        const onTouchStart = (e) => {
            e.preventDefault();
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const touch = e.touches[0];
            const x = (touch.clientX - rect.left) * dpr;
            const y = (touch.clientY - rect.top) * dpr;
            createTrailEffect(x, y);
        };

        const onTouchMove = (e) => {
            e.preventDefault();
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const touch = e.touches[0];
            const x = (touch.clientX - rect.left) * dpr;
            const y = (touch.clientY - rect.top) * dpr;
            createTrailEffect(x, y);
        };

        const onTouchEnd = (e) => {
            e.preventDefault();
            isDrawing = false;
            lastTrailPoint = null;
            setTimeout(resetMessageNow, 1200);
        };

        const onTouchCancel = (e) => {
            e.preventDefault();
            isDrawing = false;
            lastTrailPoint = null;
        };

        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', onTouchCancel, { passive: false });

        window.addEventListener('resize', () => {
            initCanvas();
        });

        autoRippleInterval = setInterval(() => {
            if (!messageSettled) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                triggerRipple(x, y);
            }
        }, 5000);

        // Scan-line driven waterfall reset
        const scanLine = document.querySelector('.scan-line');
        
        function getScanDuration() {
            const duration = getComputedStyle(scanLine).animationDuration || '4s';
            return duration.endsWith('ms') ? parseFloat(duration) : parseFloat(duration) * 1000;
        }
        
        function flipRow(rowIndex) {
            const now = Date.now();
            const jitter = 60;
            const startIdx = rowIndex * cols;
            const endIdx = Math.min((rowIndex + 1) * cols, cells.length);
            
            for (let i = startIdx; i < endIdx; i++) {
                const cell = cells[i];
                if (!cell) continue;
                
                cell.settled = false;
                cell.nextFlipAt = now;
                cell.flipRate = 20 + Math.random() * 25;
                cell.glitchOffset = { x: 0, y: 0 };
                cell.settleAt = Date.now() + 120 + Math.random() * jitter;
            }
        }
        
        function scheduleWaterfall() {
            const duration = getScanDuration();
            for (let r = 0; r < rows; r++) {
                const delay = (r / rows) * duration;
                setTimeout(() => flipRow(r), delay);
            }
        }
        
        scanLine.addEventListener('animationstart', scheduleWaterfall);
        scanLine.addEventListener('animationiteration', scheduleWaterfall);

        initCanvas();
        animate();
    </script>
</body>
</html>
