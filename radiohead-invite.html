<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radiohead Ensemble - December 14, 2025</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }

        #board {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        .scan-line {
            position: fixed;
            width: 100%;
            height: 3px;
            background: linear-gradient(transparent, rgba(139, 0, 139, 0.5), transparent);
            animation: scan 8s linear infinite;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes scan {
            0% { top: 0%; }
            100% { top: 100%; }
        }

        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            opacity: 0.02;
            z-index: 5;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.2' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            animation: noise-shift 0.5s infinite;
        }

        @keyframes noise-shift {
            0%, 100% { opacity: 0.02; }
            50% { opacity: 0.04; }
        }
        
        @media (max-width: 767px) {
            .noise-overlay {
                opacity: 0.01;
            }
            
            @keyframes noise-shift {
                0%, 100% { opacity: 0.01; }
                50% { opacity: 0.02; }
            }
        }

        .tunnel-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            perspective: 500px;
            overflow: hidden;
            z-index: 0;
        }

        .tunnel {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200%;
            height: 200%;
            transform-style: preserve-3d;
            animation: tunnel-rotate 60s linear infinite;
        }

        .tunnel-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            border: 2px solid rgba(139, 0, 139, 0.3);
            border-radius: 10%;
            transform-origin: center center;
            animation: tunnel-zoom 20s linear infinite;
        }

        .tunnel-ring:nth-child(1) { animation-delay: 0s; width: 20%; height: 20%; margin: -10% 0 0 -10%; }
        .tunnel-ring:nth-child(2) { animation-delay: -2s; width: 20%; height: 20%; margin: -10% 0 0 -10%; }
        .tunnel-ring:nth-child(3) { animation-delay: -4s; width: 20%; height: 20%; margin: -10% 0 0 -10%; }
        .tunnel-ring:nth-child(4) { animation-delay: -6s; width: 20%; height: 20%; margin: -10% 0 0 -10%; }
        .tunnel-ring:nth-child(5) { animation-delay: -8s; width: 20%; height: 20%; margin: -10% 0 0 -10%; }
        .tunnel-ring:nth-child(6) { animation-delay: -10s; width: 20%; height: 20%; margin: -10% 0 0 -10%; }
        .tunnel-ring:nth-child(7) { animation-delay: -12s; width: 20%; height: 20%; margin: -10% 0 0 -10%; }
        .tunnel-ring:nth-child(8) { animation-delay: -14s; width: 20%; height: 20%; margin: -10% 0 0 -10%; }
        .tunnel-ring:nth-child(9) { animation-delay: -16s; width: 20%; height: 20%; margin: -10% 0 0 -10%; }
        .tunnel-ring:nth-child(10) { animation-delay: -18s; width: 20%; height: 20%; margin: -10% 0 0 -10%; }

        @keyframes tunnel-zoom {
            0% {
                transform: scale(0.1) translateZ(0px);
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                transform: scale(8) translateZ(0px);
                opacity: 0;
            }
        }

        @keyframes tunnel-rotate {
            0% {
                transform: translate(-50%, -50%) rotateZ(0deg);
            }
            100% {
                transform: translate(-50%, -50%) rotateZ(360deg);
            }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
</head>
<body>
    <div class="tunnel-container">
        <div class="tunnel">
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
        </div>
    </div>
    <canvas id="board"></canvas>
    <div class="scan-line"></div>
    <div class="noise-overlay"></div>
    
    <div class="sr-only">
        RADIOHEAD ENSEMBLE
        December 14, 2025 at 4:00 PM
        Old Town School of Folk Music
        909 West Armitage
        Free | BYOB
        A Live Performance
    </div>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        
        const CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/~`█▓▒░';
        const MESSAGE_LINES = [
            'RADIOHEAD',
            'ENSEMBLE',
            '',
            'DECEMBER 14 2025',
            '4:00 PM',
            '',
            'OLD TOWN SCHOOL',
            'OF FOLK MUSIC',
            '909 W ARMITAGE',
            '',
            'FREE | BYOB'
        ];

        const GOTH_COLORS = [
            '#8B008B', // dark magenta
            '#4B0082', // indigo
            '#800080', // purple
            '#9400D3', // dark violet
            '#6A0DAD', // purple
            '#663399', // rebecca purple
            '#8A2BE2', // blue violet
            '#9932CC', // dark orchid
            '#BA55D3', // medium orchid
            '#FF00FF', // magenta
            '#DA70D6', // orchid
            '#EE82EE', // violet
        ];

        // Theme configuration
        const HUE_MODE = 'interactive'; // 'interactive', 'sequence', 'random'
        const THEME_WAVE_SPEED = 1.2; // ms per pixel - slow creeping like tendrils
        const COLORED_MESSAGE_TEXT = true; // true = colored text, false = white text with colored glow
        
        // Viral spread configuration
        const VIRAL_NOISE_SCALE = 0.08; // Frequency of noise (lower = broader structures)
        const VIRAL_NOISE_AMP = 0.8; // Amplitude of noise variation
        const VIRAL_JITTER = 0.12; // Random jitter per step
        const ANISO_AMP = 0.25; // Angular anisotropy amplitude
        const ANISO_FREQ = 6; // Angular anisotropy frequency

        let cols, rows, cellWidth, cellHeight;
        let cells = [];
        let messageMap = [];
        let ripples = [];
        let time = 0;
        let glitchBands = [];
        let autoRippleInterval = null;
        let messageSettled = false;
        let trailEffects = [];
        let isDrawing = false;
        let lastTrailPoint = null;
        
        // Theme wave state
        let currentThemeHue = 280; // Start with purple/magenta
        let activeThemeWave = null;
        let lastThemeWaveTime = 0;
        let sequenceHueIndex = 0;

        // Simple coherent noise function (value noise with smoothstep interpolation)
        function valueNoise(x, y) {
            // Simple hash function for pseudo-random values
            const hash = (x, y) => {
                let h = (x * 374761393 + y * 668265263) & 0x7fffffff;
                h = (h ^ (h >> 13)) * 1274126177;
                return ((h ^ (h >> 16)) & 0x7fffffff) / 0x7fffffff;
            };
            
            const x0 = Math.floor(x);
            const x1 = x0 + 1;
            const y0 = Math.floor(y);
            const y1 = y0 + 1;
            
            const sx = x - x0;
            const sy = y - y0;
            
            // Smoothstep interpolation
            const smoothstep = t => t * t * (3 - 2 * t);
            const tx = smoothstep(sx);
            const ty = smoothstep(sy);
            
            // Get corner values
            const c00 = hash(x0, y0);
            const c10 = hash(x1, y0);
            const c01 = hash(x0, y1);
            const c11 = hash(x1, y1);
            
            // Bilinear interpolation
            const nx0 = c00 * (1 - tx) + c10 * tx;
            const nx1 = c01 * (1 - tx) + c11 * tx;
            return nx0 * (1 - ty) + nx1 * ty;
        }
        
        // Fractional Brownian Motion (fBm) - layered noise for richness
        function fbm(x, y, octaves = 3) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;
            
            for (let i = 0; i < octaves; i++) {
                value += valueNoise(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return value / maxValue;
        }
        
        // Simple priority queue (min-heap) for Dijkstra
        class PriorityQueue {
            constructor() {
                this.heap = [];
            }
            
            push(item, priority) {
                this.heap.push({ item, priority });
                this.bubbleUp(this.heap.length - 1);
            }
            
            pop() {
                if (this.heap.length === 0) return null;
                const result = this.heap[0];
                const end = this.heap.pop();
                if (this.heap.length > 0) {
                    this.heap[0] = end;
                    this.bubbleDown(0);
                }
                return result;
            }
            
            bubbleUp(index) {
                while (index > 0) {
                    const parentIndex = Math.floor((index - 1) / 2);
                    if (this.heap[index].priority >= this.heap[parentIndex].priority) break;
                    [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
                    index = parentIndex;
                }
            }
            
            bubbleDown(index) {
                while (true) {
                    const leftChild = 2 * index + 1;
                    const rightChild = 2 * index + 2;
                    let smallest = index;
                    
                    if (leftChild < this.heap.length && this.heap[leftChild].priority < this.heap[smallest].priority) {
                        smallest = leftChild;
                    }
                    if (rightChild < this.heap.length && this.heap[rightChild].priority < this.heap[smallest].priority) {
                        smallest = rightChild;
                    }
                    if (smallest === index) break;
                    
                    [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
                    index = smallest;
                }
            }
            
            isEmpty() {
                return this.heap.length === 0;
            }
        }

        class TrailEffect {
            constructor(x, y, startTime) {
                this.x = x;
                this.y = y;
                this.startTime = startTime;
                this.duration = 6000; // 6 seconds
                this.affectedCells = [];
                this.originalStates = new Map();
                
                // Find cells within radius and store their original states
                const radius = 100 + Math.random() * 100;
                cells.forEach(cell => {
                    const dx = cell.x - x;
                    const dy = cell.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius) {
                        this.affectedCells.push({
                            cell: cell,
                            distance: dist,
                            angle: Math.atan2(dy, dx)
                        });
                        
                        // Store original state
                        this.originalStates.set(cell, {
                            char: cell.currentChar,
                            isMessage: cell.isMessage,
                            targetChar: cell.targetChar,
                            settled: cell.settled,
                            brightness: cell.brightness,
                            hue: cell.hue
                        });
                    }
                });
            }
            
            update(currentTime) {
                const elapsed = currentTime - this.startTime;
                const progress = Math.min(elapsed / this.duration, 1);
                
                if (progress < 0.5) {
                    // First 3 seconds: ripple out effect
                    const rippleProgress = progress * 2;
                    this.affectedCells.forEach(({ cell, distance, angle }) => {
                        const ripplePhase = (distance / 200) - rippleProgress * 2;
                        
                        if (Math.abs(ripplePhase) < 0.3) {
                            // Transform character
                            cell.currentChar = CHARSET[Math.floor(Math.random() * CHARSET.length)];
                            cell.brightness = 0.8 + Math.random() * 0.2;
                            // Don't change hue - let theme system control it
                            
                            // Add ripple displacement
                            const intensity = 1 - Math.abs(ripplePhase) / 0.3;
                            cell.glitchOffset = {
                                x: Math.cos(angle) * intensity * 8,
                                y: Math.sin(angle) * intensity * 8
                            };
                        }
                    });
                } else {
                    // Last 3 seconds: return to original state
                    const returnProgress = (progress - 0.5) * 2;
                    this.affectedCells.forEach(({ cell }) => {
                        const original = this.originalStates.get(cell);
                        if (returnProgress > 0.8) {
                            if (cell.isMessage) {
                                // Message cells always snap back to their canonical state
                                cell.currentChar = cell.targetChar;
                                cell.settled = true;
                                cell.flipRate = Infinity;
                                cell.brightness = 1;
                                cell.glitchOffset = { x: 0, y: 0 };
                            } else if (original) {
                                // Non-message cells return to their snapshot state
                                cell.currentChar = original.char;
                                cell.brightness = original.brightness;
                                // Don't restore hue - let theme system control it
                                cell.glitchOffset = { x: 0, y: 0 };
                                cell.settled = original.settled;
                            }
                        }
                    });
                }
                
                return progress >= 1;
            }
        }

        class ThemeWave {
            constructor(targetHue, originX, originY, startTime) {
                this.targetHue = targetHue;
                this.originX = originX;
                this.originY = originY;
                this.startTime = startTime;
                this.speed = THEME_WAVE_SPEED;
                
                // Find origin cell (nearest to click point)
                let originCell = cells[0];
                let minDist = Infinity;
                cells.forEach(cell => {
                    const dx = cell.x - originX;
                    const dy = cell.y - originY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        originCell = cell;
                    }
                });
                
                // Dijkstra's algorithm with noise-modulated edge costs for viral spread
                const times = new Array(cells.length).fill(Infinity);
                const visited = new Array(cells.length).fill(false);
                const pq = new PriorityQueue();
                
                const originIdx = cells.indexOf(originCell);
                times[originIdx] = startTime;
                pq.push(originIdx, startTime);
                
                // Helper to get cell index from row/col
                const getCellIdx = (row, col) => {
                    if (row < 0 || row >= rows || col < 0 || col >= cols) return -1;
                    return row * cols + col;
                };
                
                // 8-neighbor connectivity
                const neighbors = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];
                
                let maxTime = startTime;
                
                while (!pq.isEmpty()) {
                    const current = pq.pop();
                    const idx = current.item;
                    const currentTime = current.priority;
                    
                    if (visited[idx]) continue;
                    visited[idx] = true;
                    
                    const cell = cells[idx];
                    const row = cell.row;
                    const col = cell.col;
                    
                    // Process neighbors
                    neighbors.forEach(([dr, dc]) => {
                        const nRow = row + dr;
                        const nCol = col + dc;
                        const nIdx = getCellIdx(nRow, nCol);
                        
                        if (nIdx === -1 || visited[nIdx]) return;
                        
                        const nCell = cells[nIdx];
                        
                        // Calculate step distance in pixels
                        const dx = nCell.x - cell.x;
                        const dy = nCell.y - cell.y;
                        const stepDist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Compute cost multiplier with coherent noise + jitter + anisotropy
                        const noiseValue = fbm(nCol * VIRAL_NOISE_SCALE, nRow * VIRAL_NOISE_SCALE, 2);
                        const jitter = (Math.random() - 0.5) * VIRAL_JITTER;
                        
                        // Angular anisotropy for extra irregularity
                        const angleFromOrigin = Math.atan2(nCell.y - originY, nCell.x - originX);
                        const anisotropy = ANISO_AMP * Math.sin(ANISO_FREQ * angleFromOrigin);
                        
                        const costMultiplier = Math.max(0.2, 1 + VIRAL_NOISE_AMP * (noiseValue - 0.5) + jitter + anisotropy);
                        
                        // Edge time = step distance * speed * cost multiplier
                        const edgeTime = stepDist * this.speed * costMultiplier;
                        const newTime = currentTime + edgeTime;
                        
                        if (newTime < times[nIdx]) {
                            times[nIdx] = newTime;
                            pq.push(nIdx, newTime);
                            maxTime = Math.max(maxTime, newTime);
                        }
                    });
                }
                
                // Set themeSwitchAt for all cells
                cells.forEach((cell, idx) => {
                    cell.themeSwitchAt = times[idx];
                    cell.themeWaveDistance = times[idx] - startTime;
                });
                
                this.endAt = maxTime;
            }
            
            update(currentTime) {
                // Check if wave is complete
                if (currentTime >= this.endAt) {
                    currentThemeHue = this.targetHue;
                    return true; // Wave complete
                }
                
                // Apply color changes to cells that have reached their switch time
                cells.forEach(cell => {
                    if (currentTime >= cell.themeSwitchAt && cell.appliedThemeHue !== this.targetHue) {
                        cell.appliedThemeHue = this.targetHue;
                        
                        // Add a brief brightness spark at the wavefront
                        const timeSinceSwitch = currentTime - cell.themeSwitchAt;
                        if (timeSinceSwitch < 80) {
                            cell.flashUntil = currentTime + 120;
                        }
                    }
                });
                
                return false; // Wave still active
            }
        }

        class Cell {
            constructor(x, y, col, row) {
                this.x = x;
                this.y = y;
                this.col = col;
                this.row = row;
                this.currentChar = this.randomChar();
                this.targetChar = null;
                this.isMessage = false;
                this.flipRate = 30 + Math.random() * 90;
                this.nextFlipAt = time + Math.random() * 100;
                this.settleAt = Infinity;
                this.settled = false;
                this.hue = Math.random() * 360;
                this.brightness = 0.3 + Math.random() * 0.7;
                this.glitchOffset = { x: 0, y: 0 };
                this.appliedThemeHue = currentThemeHue;
                this.themeSwitchAt = 0;
                this.themeWaveDistance = 0;
                this.flashUntil = 0;
            }

            randomChar() {
                return CHARSET[Math.floor(Math.random() * CHARSET.length)];
            }

            update(now) {
                if (now >= this.nextFlipAt && !this.settled) {
                    this.currentChar = this.randomChar();
                    this.nextFlipAt = now + this.flipRate;
                }

                if (now >= this.settleAt && !this.settled) {
                    if (this.isMessage && this.targetChar) {
                        this.currentChar = this.targetChar;
                        this.settled = true;
                        this.flipRate = Infinity;
                        this.brightness = 1;
                    } else {
                        this.flipRate = 200 + Math.random() * 300;
                        this.brightness *= 0.15;
                    }
                }

                if (this.settled && !this.isMessage && Math.random() < 0.001) {
                    this.currentChar = this.randomChar();
                    setTimeout(() => {
                        this.currentChar = this.targetChar;
                    }, 50);
                }
            }

            draw() {
                const drawX = this.x + this.glitchOffset.x;
                const drawY = this.y + this.glitchOffset.y;
                
                if (this.isMessage && this.settled) {
                    ctx.globalAlpha = 1;
                    
                    if (COLORED_MESSAGE_TEXT) {
                        // Colored text with colored glow
                        ctx.fillStyle = themeColorForCell(this, true);
                        ctx.shadowColor = themeGlowColor(this.appliedThemeHue);
                        ctx.shadowBlur = 12;
                        ctx.fillText(this.currentChar, drawX, drawY);
                        ctx.shadowBlur = 0;
                    } else {
                        // White text with colored glow (original style)
                        ctx.fillStyle = '#fff';
                        ctx.shadowColor = themeGlowColor(this.appliedThemeHue);
                        ctx.shadowBlur = 12;
                        ctx.fillText(this.currentChar, drawX, drawY);
                        ctx.shadowBlur = 0;
                    }
                } else {
                    // Non-message cells: use theme color with brightness-based alpha
                    const effectiveBrightness = (time < this.flashUntil) ? Math.max(this.brightness, 0.9) : this.brightness;
                    ctx.globalAlpha = effectiveBrightness;
                    ctx.fillStyle = themeColorForCell(this, false);
                    ctx.fillText(this.currentChar, drawX, drawY);
                }
                
                ctx.globalAlpha = 1;
            }
        }
        
        // Helper function to generate theme-based HSL color for a cell
        function themeColorForCell(cell, isMessage) {
            let hue = cell.appliedThemeHue;
            
            // Add small hue jitter during glitches (only for non-message cells)
            if (!isMessage && cell.glitchOffset.x !== 0) {
                hue += (Math.random() - 0.5) * 10; // ±5 degree jitter
            }
            
            if (isMessage) {
                // Message cells: high lightness for legibility
                return `hsl(${hue}, 100%, 92%)`;
            } else {
                // Non-message cells: vary lightness based on brightness
                const saturation = 80 + Math.random() * 10; // 80-90%
                const lightness = 25 + 55 * cell.brightness; // 25-80% based on brightness
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            }
        }
        
        // Helper function to generate glow color
        function themeGlowColor(hue) {
            return `hsl(${hue}, 100%, 55%)`;
        }
        
        // Function to compute next hue based on mode and position
        function computeNextHue(x, y) {
            if (HUE_MODE === 'interactive') {
                // Map click position to hue based on angle from center
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const angle = Math.atan2(dy, dx); // -π to π
                const normalizedAngle = (angle + Math.PI) / (2 * Math.PI); // 0 to 1
                const angleHue = normalizedAngle * 360;
                
                // Slight bias toward previous hue to reduce jarring jumps
                const nextHue = currentThemeHue * 0.15 + angleHue * 0.85;
                return nextHue % 360;
            } else if (HUE_MODE === 'sequence') {
                // ROYGBIV sequence with golden angle stepping
                const goldenAngle = 137.5;
                sequenceHueIndex++;
                return (sequenceHueIndex * goldenAngle) % 360;
            } else if (HUE_MODE === 'random') {
                // Random hue
                return Math.random() * 360;
            }
            return currentThemeHue;
        }
        
        // Function to start a theme wave
        function startThemeWave(x, y) {
            const now = Date.now();
            
            // Cooldown to prevent double-triggering
            if (now - lastThemeWaveTime < 300) {
                return;
            }
            
            lastThemeWaveTime = now;
            
            // Compute next hue
            const targetHue = computeNextHue(x, y);
            
            // Create and start the theme wave
            activeThemeWave = new ThemeWave(targetHue, x, y, now);
        }

        function initCanvas() {
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            
            const isMobile = window.innerWidth < 768;
            const fontSize = isMobile ? 32 : 60;
            ctx.font = `bold ${fontSize * dpr}px "Courier New", monospace`;
            ctx.textBaseline = 'top';
            
            const metrics = ctx.measureText('M');
            cellWidth = metrics.width;
            cellHeight = fontSize * dpr * 1.2;
            
            cols = Math.floor(canvas.width / cellWidth);
            rows = Math.floor(canvas.height / cellHeight);
            
            cells = [];
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * cellWidth;
                    const y = row * cellHeight;
                    cells.push(new Cell(x, y, col, row));
                }
            }
            
            createMessageMap();
            triggerRipple(canvas.width / 2, canvas.height / 2);
        }

        function createMessageMap() {
            messageMap = [];
            
            // Calculate starting row for centered message
            const startRow = Math.floor((rows - MESSAGE_LINES.length) / 2);
            
            MESSAGE_LINES.forEach((line, lineIdx) => {
                if (line.length === 0) return; // Skip empty lines
                
                const row = startRow + lineIdx;
                if (row < 0 || row >= rows) return;
                
                // Calculate starting column for centered line
                const startCol = Math.floor((cols - line.length) / 2);
                
                // Assign each character to a specific grid cell
                for (let charIdx = 0; charIdx < line.length; charIdx++) {
                    const col = startCol + charIdx;
                    if (col < 0 || col >= cols) continue;
                    
                    // Find the cell at this row/col
                    const cellIndex = row * cols + col;
                    if (cellIndex >= 0 && cellIndex < cells.length) {
                        const cell = cells[cellIndex];
                        cell.isMessage = true;
                        cell.targetChar = line[charIdx];
                        messageMap.push(cell);
                    }
                }
            });
        }

        function triggerRipple(x, y) {
            const speed = 0.3;
            const jitter = 50;
            
            cells.forEach(cell => {
                const dx = cell.x - x;
                const dy = cell.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                cell.settleAt = time + dist * speed + Math.random() * jitter;
                cell.settled = false;
            });
        }

        function resetMessageNow() {
            if (!messageMap || messageMap.length === 0) return;
            messageMap.forEach(cell => {
                if (!cell) return;
                cell.currentChar = cell.targetChar;
                cell.settled = true;
                cell.flipRate = Infinity;
                cell.brightness = 1;
                cell.glitchOffset = { x: 0, y: 0 };
            });
        }

        function triggerGlitchBand() {
            const isHorizontal = Math.random() > 0.5;
            const position = Math.random();
            const thickness = 3 + Math.floor(Math.random() * 8);
            const duration = 100 + Math.random() * 150;
            const endTime = time + duration;
            
            glitchBands.push({
                isHorizontal,
                position,
                thickness,
                endTime,
                offset: { x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4 }
            });
        }

        function updateGlitchBands() {
            glitchBands = glitchBands.filter(band => time < band.endTime);
            
            cells.forEach(cell => {
                cell.glitchOffset = { x: 0, y: 0 };
            });
            
            glitchBands.forEach(band => {
                cells.forEach(cell => {
                    const pos = band.isHorizontal ? cell.row : cell.col;
                    const max = band.isHorizontal ? rows : cols;
                    const bandPos = band.position * max;
                    
                    if (Math.abs(pos - bandPos) < band.thickness && !(cell.isMessage && cell.settled)) {
                        cell.glitchOffset = band.offset;
                        // Don't change hue - let theme system control it
                        // The small hue jitter is handled in themeColorForCell() when glitchOffset is active
                    }
                });
            });
        }

        function animate() {
            time = Date.now();
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            updateGlitchBands();
            
            // Update theme wave
            if (activeThemeWave) {
                const waveComplete = activeThemeWave.update(time);
                if (waveComplete) {
                    activeThemeWave = null;
                }
            }
            
            // Update trail effects
            trailEffects = trailEffects.filter(effect => !effect.update(time));
            
            cells.forEach(cell => {
                cell.update(time);
                cell.draw();
            });
            
            // Check if message has settled
            if (!messageSettled && messageMap.length > 0) {
                const allSettled = messageMap.every(cell => cell.settled);
                if (allSettled) {
                    messageSettled = true;
                    if (autoRippleInterval) {
                        clearInterval(autoRippleInterval);
                        autoRippleInterval = null;
                    }
                }
            }
            
            if (Math.random() < 0.02) {
                triggerGlitchBand();
            }
            
            requestAnimationFrame(animate);
        }

        function createTrailEffect(x, y) {
            // Only create trail if enough distance from last point
            if (lastTrailPoint) {
                const dx = x - lastTrailPoint.x;
                const dy = y - lastTrailPoint.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minStep = window.innerWidth < 768 ? 15 : 30;
                if (dist < minStep) return; // Minimum distance between trail points
            }
            
            trailEffects.push(new TrailEffect(x, y, time));
            lastTrailPoint = { x, y };
        }

        // Mouse drag events
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;
            
            // Start theme wave on mousedown
            startThemeWave(x, y);
            createTrailEffect(x, y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;
            createTrailEffect(x, y);
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            lastTrailPoint = null;
            setTimeout(resetMessageNow, 1200);
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            lastTrailPoint = null;
        });

        // Touch events for mobile
        const onTouchStart = (e) => {
            e.preventDefault();
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const touch = e.touches[0];
            const x = (touch.clientX - rect.left) * dpr;
            const y = (touch.clientY - rect.top) * dpr;
            
            // Start theme wave on touchstart
            startThemeWave(x, y);
            createTrailEffect(x, y);
        };

        const onTouchMove = (e) => {
            e.preventDefault();
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const touch = e.touches[0];
            const x = (touch.clientX - rect.left) * dpr;
            const y = (touch.clientY - rect.top) * dpr;
            createTrailEffect(x, y);
        };

        const onTouchEnd = (e) => {
            e.preventDefault();
            isDrawing = false;
            lastTrailPoint = null;
            setTimeout(resetMessageNow, 1200);
        };

        const onTouchCancel = (e) => {
            e.preventDefault();
            isDrawing = false;
            lastTrailPoint = null;
        };

        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', onTouchCancel, { passive: false });

        window.addEventListener('resize', () => {
            initCanvas();
        });

        autoRippleInterval = setInterval(() => {
            if (!messageSettled) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                triggerRipple(x, y);
            }
        }, 5000);

        // Scan-line driven waterfall reset
        const scanLine = document.querySelector('.scan-line');
        
        function getScanDuration() {
            const duration = getComputedStyle(scanLine).animationDuration || '4s';
            return duration.endsWith('ms') ? parseFloat(duration) : parseFloat(duration) * 1000;
        }
        
        function flipRow(rowIndex) {
            const now = Date.now();
            const jitter = 60;
            const startIdx = rowIndex * cols;
            const endIdx = Math.min((rowIndex + 1) * cols, cells.length);
            
            for (let i = startIdx; i < endIdx; i++) {
                const cell = cells[i];
                if (!cell) continue;
                
                cell.settled = false;
                cell.nextFlipAt = now;
                cell.flipRate = 20 + Math.random() * 25;
                cell.glitchOffset = { x: 0, y: 0 };
                cell.settleAt = Date.now() + 120 + Math.random() * jitter;
            }
        }
        
        function scheduleWaterfall() {
            const duration = getScanDuration();
            for (let r = 0; r < rows; r++) {
                const delay = (r / rows) * duration;
                setTimeout(() => flipRow(r), delay);
            }
        }
        
        scanLine.addEventListener('animationstart', scheduleWaterfall);
        scanLine.addEventListener('animationiteration', scheduleWaterfall);

        initCanvas();
        animate();
    </script>
</body>
</html>
